import os
import json

from py2neo import Graph, Node


# 类名
class MedicalGraph:
    '''初始化函数 self是类自己'''
    '''功能:初始化导入数据的路径，运行连接neo4j'''
    '''
    参数:
        无
    返回:
        无
    '''

    def __init__(self, url, user, password):
        # 初始化导入数据的路径
        # cur_dir = '/'.join(os.path.abspath(__file__).split('/')[:-1])
        cur_dir = os.path.dirname(__file__)
        print(cur_dir)
        self.company_path = os.path.join(cur_dir, "data\init_db\实体-公司.json")
        self.link_path = os.path.join(cur_dir, "data\init_db\实体-产业链环节.json")
        self.product_path = os.path.join(cur_dir, "data\init_db\实体-产品.json")
        self.news_path = os.path.join(cur_dir, "data\init_db\实体-新闻.json")
        self.company_link_path = os.path.join(cur_dir, "data\init_db\关系-公司与环节.json")
        self.link_link_path = os.path.join(cur_dir, "data\init_db\关系-环节与环节.json")
        self.link_product_path = os.path.join(cur_dir, "data\init_db\关系-环节与产品.json")
        self.company_product_path = os.path.join(cur_dir, "data\init_db\关系-公司与产品.json")
        self.product_product_path = os.path.join(cur_dir, "data\init_db\关系-产品与产品.json")
        self.company_suppliers_path = os.path.join(cur_dir, "data\init_db\关系-公司与供应商.json")
        self.company_client_path = os.path.join(cur_dir, "data\init_db\关系-公司与客户.json")
        self.company_news_path = os.path.join(cur_dir, "data\init_db\关系-公司与新闻.json")
        # 连接数据库
        # self.g = Graph('http://localhost:7474/browser/', user="neo4j",
        #                password="123456", name="neo4j")
        self.g = Graph(url, user=user, password=password, name="neo4j")
        #相关语句
        self.cql = {
            "产业链相关产品" : "MATCH (p:product)-[:相关产品]-(:link)SET p:产业链相关产品"
        }

    '''加载数据'''
    '''功能:读入用于初始化的json数据文件,并返回数组形式'''
    '''
    参数:
        filepath:文件位置
    返回:
        存有数据的数组
    '''

    def load_data(self, filepath):
        datas = []
        with open(filepath, 'r', encoding="utf-8") as f:
            data = json.load(f)
            for line in data:
                if not line:
                    continue
                datas.append(line)
        return datas

    '''建立节点'''
    '''功能:生成创建实体结点的CQL语言，并用neo4j运行'''
    '''
    参数:
        label:实体结点的类型
        nodes:结点的属性
    返回:
        1
    '''

    def create_node(self, label, nodes):
        count = 0
        for node in nodes:
            bodies = []
            for k, v in node.items():
                body = k + ":" + "'%s'" % v
                bodies.append(body)
            query_body = ', '.join(bodies)
            try:
                sql = "CREATE (:%s{%s})" % (label, query_body)
                # print(sql)
                self.g.run(sql)
                count += 1
            except:
                pass
            # 打印成功了几个，总数是几个
            print(label, count, len(nodes))
       return 1
    '''创建知识图谱实体节点类型'''
    '''功能:第一次初始化时生成所有的实体结点'''
    '''
    参数:
        无
    返回:
        无
    '''
    def create_graphnodes(self):
        # 导入数据
        company = self.load_data(self.company_path)
        link = self.load_data(self.link_path)
        product = self.load_data(self.product_path)
        news = self.load_data(self.news_path)
        # 生成实体结点
        self.create_node('company', company)
        self.create_node('link', link)
        self.create_node('product', product)
        self.create_node('news', news)
        # 结束打印共有多少个
        print("company" + str(len(company)) + "over!!")
        print("link" + str(len(link)) + "over!!")
        print("product" + str(len(product)) + "over!!")
        print("news" + str(len(news)) + "over!!")
        return
    '''创建实体关联边'''
    '''功能:针对普通的三元组，创建没有属性的关系'''
    '''参数:
        start_node:起始结点的类型
        end_node:终止结点的类型
        edges:存储关系的数组
        from_key:起始结点的关键字（依据这个在数据库中查找，一般是name）
        end_key:终止结点的关键字（依据这个在数据库中查找，一般是name）
    '''
    def create_relationship(self, start_node, end_node, edges, from_key, end_key):
        count = 0
        for edge in edges:
            try:
                p = edge[from_key]
                q = edge[end_key]
                rel = edge["rel"]
                query = "match(p:%s),(q:%s) where p.name='%s'and q.name='%s' create (p)-[rel:%s]->(q)" % (
                    start_node, end_node, p, q, rel)
                # print(query)
                self.g.run(query)
                count += 1
                print(rel, count, all)
            except Exception as e:
                print(e)
        return

    '''创建实体关联边'''
    '''功能:针对有属性的三元组，创建附带属性的关系'''
    '''参数:
        start_node:起始结点的类型
        end_node:终止结点的类型
        edges:存储关系的数组
        from_key:起始结点的关键字（依据这个在数据库中查找，一般是name）
        end_key:终止结点的关键字（依据这个在数据库中查找，一般是name）
    '''

    def create_relationship_attr(self, start_node, end_node, edges, from_key, end_key):
        count = 0
        for edge in edges:
            # 拿取除了重要结点之外的信息
            bodies = []
            for k, v in edge.items():
                if (k != from_key and k != end_key and k != 'rel'):
                    body = k + ":" + "'%s'" % v
                    bodies.append(body)
            query_body = ', '.join(bodies)
            print(query_body)
            try:
                p = edge[from_key]
                q = edge[end_key]
                rel = edge["rel"]
                if (rel == '主营产品'):
                    query = "match(p:%s),(q:%s) where p.name='%s'and q.name='%s' create (p)-[rel:%s{%s}]->(q)" % (
                        start_node, end_node, p, q, rel, query_body)
                elif (rel == '相关产品'):
                    query = "match(p:%s),(q:%s) where p.name='%s'and q.name='%s' create (p)-[rel:%s]->(q)" % (
                        start_node, end_node, p, q, rel)
                else:
                    query = "match(p:%s),(q:%s) where p.fullname='%s'and q.name='%s' create (p)-[rel:%s{%s}]->(q)" % (
                        start_node, end_node, p, q, rel, query_body)
                #print(query)
                self.g.run(query)
                count += 1
                print(rel, count, len(edges))
            except:
                pass
        return

    '''创建实体关系边'''
    '''功能:第一次初始化时生成所有的关系边'''
    '''
    参数:
        无
    返回:
        无
    '''

    def create_graphrels(self):
        link_link = self.load_data(self.link_link_path)
        self.create_relationship(
            'link', 'link', link_link, "from", "to")
        company_link = self.load_data(self.company_link_path)
        self.create_relationship(
            'company', 'link', company_link, "company", "link")
        company_product = self.load_data(self.company_product_path)
        self.create_relationship_attr(
            'company', 'product', company_product, "company", "product")
        link_product = self.load_data(self.link_product_path)
        self.create_relationship_attr(
            'link', 'product', link_product, "产业链环节", "产品")
        product_product = self.load_data(self.product_product_path)
        self.create_relationship(
            'product', 'product', product_product, "from_entity", "to_entity")
        company_news = self.load_data(self.company_news_path)
        self.create_relationship(
            'news', 'company', company_news, "news", "company")
        company_suppliers = self.load_data(self.company_suppliers_path)
        self.create_relationship_attr(
            'company', 'company', company_suppliers, "from", "to")
        company_client = self.load_data(self.company_client_path)
        self.create_relationship_attr(
            'company', 'company', company_client, "from", "to")

    '''第一次初始化'''
    '''功能:第一次初始化时生成所有的关系边'''
    '''
    参数:
        无
    返回:
        无
    '''

    def build_graph(self):
        self.create_graphnodes()
        self.create_graphrels()
        #创建
        self.g.run(self.cql["产业链相关产品"])
        # link_product = self.load_data(self.link_product_path)
        # self.create_relationship_attr(
        #     'link', 'product', link_product, "产业链环节", "产品")

    def drop_graph(self):
        self.g.run("MATCH (n) DETACH DELETE n")
请帮我学习模仿上述数据库类创建的风格，这是我以前创建产业链数据库的代码，我现在希望写一段类似风格的代码，然后插入我的数据
我的数据的详细信息如下：
实体结点路径
data/实体-专利.csv
data/实体-IPC.csv
data/实体-代理机构.csv
data/实体-发明人.csv
data/实体-申请人.csv
关系路径
data/关系-专利和IPC.csv
data/关系-专利和代理机构.csv
data/关系-专利和发明人.csv
data/关系-专利和申请人.csv
专利的文件的格式如下
申请号,公开号,申请日,公开日,文献类型,名称,摘要
CN200810045361.2,CN101225743A,2008.02.04,2008.07.23,发明,一种地震区隧道减震结构的建造方法,一种地震区隧道减震结构的建造方法，其做法是：在隧道洞口段的围岩及初期支护(1)表面先铺设一层弹性材料构成的减震层(2)，该减震层(2)的纵向长度为15－50米，然后，再在减震层的外面修建二次衬砌(3)。该方法建造的隧道结构，其减震效果好，能有效地避免地震对隧道造成的损坏，且施工简单，成本低。
IPC的文件的格式如下
名称
E21D11/00
A23L5/10
代理机构的文件格式如下
名称
成都博通专利事务所
北京华科联合专利事务所
申请人的格式如下
名称 邮编
西南交通大学,610031.0
山东化氏鱼饵有限公司,276000.0
关系格式如下
专利和IPC
公开号,名称,关系
CN101225743A,E21D11/00,属于
CN205106095U,A01K97/04,属于
专利和代理机构
公开号,名称,关系
CN101225743A,成都博通专利事务所,代理
CN101899984A;CN101899984B,成都博通专利事务所,代理
专利和发明人
公开号,名称,关系
CN101225743A,何川,发明
CN101225743A,王志杰,发明
专利和申请人
公开号,名称,关系
CN101225743A,西南交通大学,申请
CN205106095U,山东化氏鱼饵有限公司,申请


运行结果如下：
Created 5803 'Patent' nodes.
Created 4080 'IPC' nodes.
Created 1430 'Agent' nodes.
Created 20484 'Inventor' nodes.
Created 3590 'Applicant' nodes.
Traceback (most recent call last):
  File "C:\Users\bug\Desktop\毕设\系统\数据\数据集处理\创建-图数据库.py", line 76, in <module>
    patent_graph.build_graph()
  File "C:\Users\bug\Desktop\毕设\系统\数据\数据集处理\创建-图数据库.py", line 57, in build_graph
    self.create_relationships(self.patent_ipc_path, 'Patent', 'IPC', 'BELONGS_TO')
  File "C:\Users\bug\Desktop\毕设\系统\数据\数据集处理\创建-图数据库.py", line 41, in create_relationships
    start_node=rel['公开号'],
KeyError: '公开号'Created 5803 'Patent' nodes.
Created 4080 'IPC' nodes.
Created 1430 'Agent' nodes.
Created 20484 'Inventor' nodes.
Created 3590 'Applicant' nodes.
Traceback (most recent call last):
  File "C:\Users\bug\Desktop\毕设\系统\数据\数据集处理\创建-图数据库.py", line 76, in <module>
    patent_graph.build_graph()
  File "C:\Users\bug\Desktop\毕设\系统\数据\数据集处理\创建-图数据库.py", line 57, in build_graph
    self.create_relationships(self.patent_ipc_path, 'Patent', 'IPC', 'BELONGS_TO')
  File "C:\Users\bug\Desktop\毕设\系统\数据\数据集处理\创建-图数据库.py", line 41, in create_relationships
    start_node=rel['公开号'],
KeyError: '公开号'
请注意我希望专利的主键是他的公开号，关系三元组在找专利时也用的公开号，请在针对上面的错误，给我一份完整的代码，另外代码请加详细的中文注释


目前还是报错
Created 5803 'Patent' nodes.
Created 4080 'IPC' nodes.
Created 1430 'Agent' nodes.
Created 20484 'Inventor' nodes.
Created 3590 'Applicant' nodes.
Traceback (most recent call last):
  File "C:\Users\bug\Desktop\毕设\系统\数据\数据集处理\创建-图数据库.py", line 91, in <module>
    patent_graph.build_graph()
  File "C:\Users\bug\Desktop\毕设\系统\数据\数据集处理\创建-图数据库.py", line 70, in build_graph
    self.create_relationships(self.patent_ipc_path, 'Patent', 'IPC', 'BELONGS_TO')
  File "C:\Users\bug\Desktop\毕设\系统\数据\数据集处理\创建-图数据库.py", line 43, in create_relationships
    p = rel['公开号'].strip()  # 请确认此列名与CSV中的一致
KeyError: '公开号'

Process finished with exit code 1

代码如下
import os
import csv
from py2neo import Graph, Node, Relationship


class PatentGraph:
    def __init__(self, url, user, password):
        # 当前文件所在目录
        cur_dir = os.path.dirname(__file__)
        # 实体节点文件路径
        self.patent_path = os.path.join(cur_dir, "data/实体-专利.csv")
        self.ipc_path = os.path.join(cur_dir, "data/实体-IPC.csv")
        self.agent_path = os.path.join(cur_dir, "data/实体-代理机构.csv")
        self.inventor_path = os.path.join(cur_dir, "data/实体-发明人.csv")
        self.applicant_path = os.path.join(cur_dir, "data/实体-申请人.csv")
        # 关系文件路径
        self.patent_ipc_path = os.path.join(cur_dir, "data/关系-专利和IPC.csv")
        self.patent_agent_path = os.path.join(cur_dir, "data/关系-专利和代理机构.csv")
        self.patent_inventor_path = os.path.join(cur_dir, "data/关系-专利和发明人.csv")
        self.patent_applicant_path = os.path.join(cur_dir, "data/关系-专利和申请人.csv")

        # 连接Neo4j图数据库
        self.graph = Graph(url, user=user, password=password, name="neo4j")

    # 加载CSV文件并返回字典列表
    def load_csv(self, file_path):
        with open(file_path, 'r', encoding='utf-8') as file:
            return list(csv.DictReader(file))

    # 创建节点
    def create_nodes(self, label, nodes):
        for node in nodes:
            properties = {k: v for k, v in node.items() if v not in ['', 'null', 'NULL']}
            self.graph.create(Node(label, **properties))
        print(f"Created {len(nodes)} '{label}' nodes.")

    # 创建关系
    def create_relationships(self, file_path, start_label, end_label, rel_type):
        # 加载关系数据
        relationships = self.load_csv(file_path)
        for rel in relationships:
            # 修改这里以正确获取公开号
            p = rel['公开号'].strip()  # 请确认此列名与CSV中的一致
            q = rel['名称'].strip()
            # 创建关系
            self.graph.run(
                "MATCH (a:{start_label}), (b:{end_label}) "
                "WHERE a.公开号 = $start_node AND b.名称 = $end_node "
                "CREATE (a)-[:{rel_type}]->(b)",
                parameters={
                    'start_node': p,
                    'end_node': q,
                    'start_label': start_label,
                    'end_label': end_label,
                    'rel_type': rel_type
                }
            )
        print(f"Created relationships from file '{file_path}'.")

    # 构建整个图
    def build_graph(self):
        # 创建节点
        self.create_nodes('Patent', self.load_csv(self.patent_path))
        self.create_nodes('IPC', self.load_csv(self.ipc_path))
        self.create_nodes('Agent', self.load_csv(self.agent_path))
        self.create_nodes('Inventor', self.load_csv(self.inventor_path))
        self.create_nodes('Applicant', self.load_csv(self.applicant_path))

        # 创建关系
        self.create_relationships(self.patent_ipc_path, 'Patent', 'IPC', 'BELONGS_TO')
        self.create_relationships(self.patent_agent_path, 'Patent', 'Agent', 'REPRESENTED_BY')
        self.create_relationships(self.patent_inventor_path, 'Patent', 'Inventor', 'INVENTED_BY')
        self.create_relationships(self.patent_applicant_path, 'Patent', 'Applicant', 'APPLIED_BY')

    # 删除图中的所有节点和关系
    def delete_all(self):
        self.graph.delete_all()


# 实例化并运行
if __name__ == '__main__':
    url = 'http://localhost:7474/browser/'
    user = 'neo4j'
    password = 'CHW123d456'
    patent_graph = PatentGraph(url, user, password)

    # 如果需要清空现有数据库
    patent_graph.delete_all()

    # 使用新数据构建图
    patent_graph.build_graph()
